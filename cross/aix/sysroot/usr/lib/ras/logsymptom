#!/bin/ksh
# IBM_PROLOG_BEGIN_TAG 
# This is an automatically generated prolog. 
#  
# bos530 src/bos/usr/bin/errlg/odm/logsymptom.sh 1.5 
#  
# Licensed Materials - Property of IBM 
#  
# (C) COPYRIGHT International Business Machines Corp. 1990,1994 
# All Rights Reserved 
#  
# US Government Users Restricted Rights - Use, duplication or 
# disclosure restricted by GSA ADP Schedule Contract with IBM Corp. 
#  
# IBM_PROLOG_END_TAG 
# @(#)92	1.5  src/bos/usr/bin/errlg/odm/logsymptom.sh, cmderrlg, bos530 5/28/02 14:38:56
# Log the stack traceback from a previous dump.
# This is an error notification method.

# Name:  Exit
#
# Function:  Exit the script
#
Exit() {
	# unmount remove dump directory if present.
	if [ -n "$mountdir" ]
	then	# It's there
		umount -f $mountdir >/dev/null 2>&1
		rmdir $mountdir 2>/dev/null
	fi
	# Remove temp file if specified.
	[ -n "$tmpf" ] && rm -f $tmpf
	exit $1
}

# Log the information.
# input:  dump's file name.
Logit() {
	# Don't send the dmp_minimal output to stdout.
	/usr/lib/ras/dmprtns/dmp_minimal -e $1 2>&1 | alog $alogparms >/dev/null
	echo | alog $alogparms
}

#
# Name:  main (main body)
#
# Function:
#   This shell first gets control when a DUMP_STATS error is logged.
#   It then puts the output of sysdumpdev -L into a file for later use.
#
#   It then gets control later in the boot process, after NFS has started.
#   It uses the saved sysdumpdev -L output to find the dump, if possible.
#   If found, it runs the dmp_minimal ras service to generate a
#   stack traceback in the error log.
#   It will always delete the sysdumpdev -L output.
#
# Input:
#   If a parameter is specified, this is the first invocation of
#   this script i.e., the error notify method.


# Execution path
PATH=/usr/bin:/etc:/usr/sbin:/usr/ucb:/sbin; export PATH

pgm=`basename $0`

# Insure that temporary files are not world-writeable
umask 077

# Use C for text parsing
export LC_MESSAGES=C

# Log to alog_type of dumpsymp
alogparms="-t dumpsymp"
tmpf=/tmp/sysdumpdev-L

# mountdir is only set if we have a remote dump
mountdir=

# See if notify method?
if [ $# -ne 0 ]
then	# Error notify method.
	# Log this event
	echo "------ $pgm $*" `date` | alog $alogparms

	#Remove previous $tmpf for security
	rm -f $tmpf
	# Get info for recent dump.
	sysdumpdev -L >$tmpf
else	# Subsequent execution, from inittab.  This should be a remote dump.
	# Quit if $tmpf isn't around from the prior invocation.
	[[ ! -r $tmpf ]] && Exit 0
	dumpdev=`cat $tmpf`
	host_dir=`dirname $dumpdev`  # Looks like host:dir
	hostfile=`basename $dumpdev`
	mountdir=/tmp/mnt.$$
	# make a temporary mount point
	mkdir $mountdir
	# Try the mount
	mount $host_dir $mountdir 2>/dev/null
	if [ $? -ne 0 ]
	then	# It didn't mount
		echo "mount $host_dir $mountdir failed." | alog $alogparms
		Exit 3
	fi
	# It's mounted up
	dumpname=$mountdir"/"$hostfile
	Logit $dumpname
	Exit 0
fi

# Just exit if $tmpf isn't there.
[ -s $tmpf ] || Exit 0

# Get the dump status
dumpstat=`fgrep 'Dump status' $tmpf`
dumpstat=`echo $dumpstat | sed 's/.* \(.*$\)/\1/'`
echo "Status:$dumpstat" | alog $alogparms

# See if dump was copied.
dumpname=`fgrep 'Dump copy filename' $tmpf`
if [ -n "$dumpname" ]
then	# The dump was copied to a file.
	echo "$dumpname" | alog $alogparms
	# Get the actual filename if present.
	dumpname=`echo $dumpname | sed 's/.* \(.*$\)/\1/'`
	if [ -n "$dumpname" -a -r "$dumpname" ]
	then	# We've got the filename and can read it.
		continue

	else	# Dump not copied.
		echo "Copy file not usable." | alog $alogparms
		Exit 1
	fi

else	# Try to get dump from the device.
	# Get the dump device name.
	dumpdev=`fgrep 'Device name' $tmpf`
	dumpdev=`echo $dumpdev | sed 's/.* \(.*$\)/\1/'`
	if [ -z "$dumpdev" ]
	then	# dump device not found.
		echo "Dump device not found." | alog $alogparms
		Exit 1
	fi
	echo "Device:$dumpdev" | alog $alogparms

	# basename needed for ODM queries.
	dumpname=`basename $dumpdev`

	# See if dump device is a logical volume
	attr=`odmget -q "name = $dumpname and attribute = 'lvserial_id'" CuAt 2>/dev/null`
	if [ -n "$attr" ]
	then	# It's an LV
		dumpname=$dumpdev

	else	# Not a logical volume.
		# Check for remote dump.
		echo $dumpdev | fgrep ':' >/dev/null
		if [ $? -ne 0 ]
		then	# Not remote either.
			echo "Can't use device." | alog $alogparms
			Exit 1
		fi
		# Save the dump device for later.
		echo $dumpdev >$tmpf
		# Note we just exit, don't use Exit.
		# We'll be back after nfs is started.
		exit 0
	fi
fi

# $dumpname is either a copy filename or an LV pathname.
Logit $dumpname

Exit 0

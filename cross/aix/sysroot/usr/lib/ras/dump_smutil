#!/usr/bin/ksh
# IBM_PROLOG_BEGIN_TAG 
# This is an automatically generated prolog. 
#  
# bos53N src/bos/usr/bin/sysdumpdev/smutil/dump_smutil.sh 1.13.1.1 
#  
# Licensed Materials - Property of IBM 
#  
# COPYRIGHT International Business Machines Corp. 1988,1993 
# All Rights Reserved 
#  
# US Government Users Restricted Rights - Use, duplication or 
# disclosure restricted by GSA ADP Schedule Contract with IBM Corp. 
#  
# IBM_PROLOG_END_TAG 
# @(#)59    1.13  src/bos/usr/bin/sysdumpdev/smutil/dump_smutil.sh, cmddump, bos540  2/22/06  18:51:52

#
# COMPONENT_NAME:   CMDDUMP   SMIT shell interface program
#
# FUNCTIONS:  interfaces to sysdumpdev, cat, catpr
#
# ORIGINS: 27
#
#                  -- (                            when
# combined with the aggregated modules for this product)
# OBJECT CODE ONLY SOURCE MATERIALS
# (C) COPYRIGHT International Business Machines Corp. 1988, 1989, 1993
# All Rights Reserved
#
# US Government Users Restricted Rights - Use, duplication or
# disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
#

[ $# -gt 0 ] || { exit 0 ; }


PROGNAME=`basename $0`

# Make sure $TMPFILE is secure.
umask 077
unset PATH
export PATH=/usr/bin:/etc:/usr/sbin:/usr/ucb

typeset TMPDIR=${TMPDIR:-/tmp}/$PROGNAME.$$
typeset rc tmp

[[ ! -w ${TMPDIR%/*} ]] && {
	# Don't loop forever if our parent directory is not
	# writable.
	print -u2 "$PROGNAME: could not write to directory \"${TMPDIR%/*}\""
	exit 1
}

while ! mkdir -m 0700 $TMPDIR 2>/dev/null ; do
	TMPDIR=${TMPDIR%.*}.$(( $$ + $RANDOM ))
done
TMPFILE=$TMPDIR/tmpfile1

COPYFILEF=/var/adm/ras/copyfilename
COPYFILET=/var/adm/ras/copyfilename.org
CLEANUP1="rm -rf $TMPDIR"
CLEANUP2() {
	[ -e $COPYFILET ] && mv $COPYFILET $COPYFILEF >/dev/null 2>&1
}
trap "$CLEANUP1; CLEANUP2; exit 5 " 2

Cleanup() {
	$CLEANUP1
	exit $1
}

savelc=$LC_MESSAGES
LC_MESSAGES=C
export LC_MESSAGES

UTILNAME=$1
shift

case $UTILNAME in

#
# sysdumpdev
# put output from sysdumpdev in cmd_to_discover format
#
sysdumpdev)

USAGE_SYSDUMPDEV="
sysdumpdev -lL

-l    list current dump device settings
-L    show info on previous dump through DMP_IOCSTAT ioctl
-S    show possible dump devices
"

OPTIONS="`getopt SHlL $*`"
[ $? -eq 0 ] || { echo "$USAGE_SYSDUMPDEV" ; Cleanup 1 ; }

set -- $OPTIONS

FROMFILE=
TOFILE=
for i in $* ; do
	ARG=$1
	case $ARG in
	-l)
		OPT=-l
		;;
	-L)
		OPT=-L
		;;
	-S)
		OPT=-S
		;;
	-H)
		echo "$USAGE_SYSDUMPDEV"
		Cleanup 1
		;;
	--)
		shift
		break
		;;
	*)
		echo "$PROGNAME: invalid argument $i"
		echo "$USAGE_SYSDUMPDEV"
		Cleanup 1
		;;
	esac
	shift
done

case "$OPT" in
"")
	Cleanup 0
	;;
-l)
	sysdumpdev -l > $TMPFILE
	set `grep primary < $TMPFILE`
	PRIMARY=$2
	set `grep secondary < $TMPFILE`
	SECONDARY=$2
	echo "\
#_primary:_secondary
$PRIMARY:$SECONDARY"
	$CLEANUP1
	Cleanup 0
	;;
-L)
        # Read the output of sysdumpdev -L command
        # substitute from the beginning of the line till
        # ":" and any number of blanks after that with nothing
        # i.e.: Get rid of the label fiels.
	[ -e $COPYFILEF ] && mv $COPYFILEF $COPYFILET >/dev/null 2>&1

        # Look for a word compress in the sysdumpdev -L ouput.
        # If it is present take the uncompressed size.
        # If not there is only one size in the output and pick it.

        sysdumpdev -L 2>&1 > $TMPFILE
	LC_MESSAGES=$savelc
        grep compress $TMPFILE >/dev/null
        rc=$?
        if [ $rc -eq 0 ]
        then
        cat $TMPFILE  2>&1 | sed 's/^.*:  *//' | {
        read blank; read blank
        read device
        read major
        read minor
        read size bytes
        read usize bytes
        read date
        read status
	# Change the : in the date field to - so that smit won't
	# take it as a new field.
	echo $date | sed 's/:/-/g' | {
		read time
        	# check to make sure the device is not a remote dump file.
        	echo $device | fgrep : >/dev/null
        	rc=$?
        	if  [ $rc -eq 0 ]
        	then
          	echo `dspmsg cmddump.cat -s 1 536 "Copy a remote dump file is not allowed.\n"`
		$CLEANUP1
		CLEANUP2
          	Cleanup 1
        	else
        	echo "\
#_devicename:_madev:_midev:_size:_timestamp:_status:_targfile:
$device:$major:$minor:$size:$time:$status:/var/adm/ras/dump_file_copy.BZ:"
		$CLEANUP1
		CLEANUP2
          	Cleanup 0
        	fi
        	}
	}
        else
		# not a compressed dump
                cat $TMPFILE  2>&1 | sed 's/^.*:  *//' | {
                read blank; read blank 
                read device 
                read major 
                read minor 
                read size bytes 
                read  date 
                read status 
                # Change the : in the date field to - so that smit won't
                # take it as a new field.
                echo $date | sed 's/:/-/g' | {
                        read time
                        # check to make sure the device is not a remote dump file.
                        echo $device | fgrep : >/dev/null
                        rc=$?
                        if  [ $rc -eq 0 ]
                        then
                        echo `dspmsg cmddump.cat -s 1 536 "Copy a remote dump file is not all
owed.\n"`
		$CLEANUP1
		CLEANUP2
                        Cleanup 1
                        else
                        echo "\
#_devicename:_madev:_midev:_size:_timestamp:_status:_targfile:
$device:$major:$minor:$size:$time:$status:/var/adm/ras/dump_file_copy:"
		$CLEANUP1
		CLEANUP2
                        Cleanup 0
                        fi
                        }
                }
                fi

	;;

-S)
	LIST=
	[ -c /dev/rhd7 ] && \
		LIST="$LIST/dev/rhd7         DUMP MINIDISK\n"
	[ -c /dev/rmt0 ] && \
		LIST="$LIST/dev/rmt0         MAGTAPE\n"
	[ -c /dev/sysdumpnull ] && \
		LIST="$LIST/dev/sysdumpnull  DUMP DISABLED\n"
	echo "$LIST\c"
	Cleanup 0
	;;
esac
;;

cat)
	FILE=$1
	if [ "$FILE" = "" ] ; then
		cat
		RC=$?
	else
		FILE=`echo $FILE | sed 's/^Z//' `
		cat > $FILE
		RC=$?
	fi
	Cleanup $RC
;;

catpr)
	PRINTER=$1
	if [ "$PRINTER" = "" ] ; then
		cat
		RC=$?
	else
		PRINTER=`echo $PRINTER | sed 's/^Z//' `
		if [ -n "$PRINTER" ] ; then
		PRINTER="-P $PRINTER"
		fi
		qprt $PRINTER
		RC=$?
	fi
	Cleanup $RC
;;

esac

Cleanup 0

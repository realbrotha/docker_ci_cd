/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* bos53J src/bos/kernel/sys/POWER/ldr.h 1.26.4.3                         */
/*                                                                        */
/* Licensed Materials - Property of IBM                                   */
/*                                                                        */
/* (C) COPYRIGHT International Business Machines Corp. 1989,2006          */
/* All Rights Reserved                                                    */
/*                                                                        */
/* US Government Users Restricted Rights - Use, duplication or            */
/* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.      */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
/* static char sccsid[] = "@(#)80  1.26.4.3  src/bos/kernel/sys/POWER/ldr.h, sysldr, bos53J, j2006_17A1 3/31/06 14:20:25"; 			  */

/*
 *   COMPONENT_NAME: SYSLDR
 *
 *   ORIGINS: 27, 83
 *
 */
/*
 * LEVEL 1,  5 Years Bull Confidential Information
 */

#ifndef	_H_LDR
#define	_H_LDR	

#ifdef __cplusplus
extern "C" {
#endif

/* This file can define 2 variants of the ld_info structure, one for
   describing 32-bit processes and one for describing 64-bit processes.
   The ld_info structure is always defined by this header file and can
   be used for the argument to loadbind().

   The variant structures are generated by defining a macro at compile time.
   When you are using ptrace in a 32-bit program to debug a 64-bit
   process, define __LDINFO_PTRACE64__.  When you are using ptrace in
   a 64-bit program to debug a 32-bit process, define __LDINFO_PTRACE32__.

   The following combinations are possible:

   =====================================================================
   | Compilation |                     | Additional Structure | Field  |
   | Mode        | Macros defined      | Definitions          | Sizes  |
   |===================================================================|
   | 32-bit      | none                |                      |        |
   |-------------------------------------------------------------------|
   | 32-bit      | __LDINFO_PTRACE32__ | __ld_info32  (Note 1)| 32-bit |
   |-------------------------------------------------------------------|
   | 32-bit      | __LDINFO_PTRACE64__ | __ld_info64          | 64-bit |
   |-------------------------------------------------------------------|
   | 32-bit      | __LDINFO_PTRACE32__ | __ld_info32  (Note 1)| 32-bit |
   |             | __LDINFO_PTRACE64__ | __ld_info64          | 64-bit |
   |-------------------------------------------------------------------|
   | 64-bit      | none                |                      |        |
   |-------------------------------------------------------------------|
   | 64-bit      | __LDINFO_PTRACE32__ | __ld_info32          | 32-bit |
   |-------------------------------------------------------------------|
   | 64-bit      | __LDINFO_PTRACE64__ | __ld_info64  (Note 2)| 64-bit |
   |-------------------------------------------------------------------|
   | 64-bit      | __LDINFO_PTRACE32__ | __ld_info32          | 32-bit |
   |             | __LDINFO_PTRACE64__ | __ld_info64  (Note 2)| 64-bit |
   =====================================================================

   Note 1:  A #define __ld_info32 ld_info is generated, so 'struct ld_info'
	is identical to 'struct __ld_info32'.
   Note 2:  A #define __ld_info64 ld_info is generated, so 'struct ld_info'
	is identical to 'struct __ld_info64'.

   The same field names are generated in both structure variations,
   except that the 64-bit structure has an "ldinfo_flags" field.

   The field names and types in ld_info and its variants are as follows:

 ==============================================================================
 |                 |         __ld_info           | __ld_info32  | __ld_info64 |
 | Field Name      | 32-bit mode  | 64-bit mode  | 64-bit mode  | 32-bit mode |
 |============================================================================|
 | ldinfo_next     | uint         | uint         | uint         | uint        |
 | ldinfo_flags    | N/A          | uint         | N/A          | uint        |
 |-----------------|-----------------------------|--------------|-------------|
 ||            The following 2 fields overlay each other                     ||
 ||ldinfo_fd       | int          | int          | int          | int        ||
 ||ldinfo_core     | int          | long         | int          | ulonglong  ||
 |-----------------|-----------------------------|--------------|-------------|
 | ldinfo_textorg  | void *       | void *       | unsigned int | ulonglong   |
 | ldinfo_textsize | unsigned int | unsigned long| unsigned int | ulonglong   |
 | ldinfo_dataorg  | void *       | void *       | unsigned int | ulonglong   |
 | ldinfo_datasize | unsigned int | unsigned long| unsigned int | ulonglong   |
 | ldinfo_filename | char [2]     | char [2]     | char [2]     | char [2]    |
 ==============================================================================

 The ld_xinfo structure is used for loadquery(L_GETXINFO) and
 ptracex(PT_LDXINFO).  The size of the ld_xinfo structure is not fixed.
 New fields could possibly be added to the end of the existing structure
 definition.

*/

struct file;

#ifdef _KERNEL

/* Define the type of the ldinfo_fp field in the kernel. */
#ifdef __64BIT_KERNEL
#define __I_FP32(t,f)
#define __I_FP64(t,f)	t * f
#else
#define __I_FP32(t,f)	t * f
#define __I_FP64(t,f)	t * f
#endif

#else

/* Define the type of the ldinfo_fp field in application space. */

#define __I_FP32(t,f)	__I_PTR32(t) f	/* Type used in the kernel. */
#define __I_FP64(t,f)	__I_PTR64(t) f	/* Type used in the kernel. */
#endif

#ifdef __64BIT__
#define __I_INT32	int
#define __I_INT64	long
#define __I_PTR32(t)	unsigned int /* Type used for a 32-bit pointer when
					compiling in 64-bit mode. */
#define __I_PTR64(t)	t *
#else
#define __I_INT32	int
#define __I_INT64	long long
#define __I_PTR32(t)	t *
#define __I_PTR64(t)	unsigned long long /* Type used for a 64-bit pointer
					      when compiling in 32-bit mode. */
#endif
#define __I_EMPTY

#define __I_FIELDS(__I_INT, __I_PTR, __I_FP, __I_RESERVED)                     \
	uint			ldinfo_next;	    /* offset from current     \
						       entry of next entry     \
						       (or 0 if last entry) */ \
	__I_RESERVED				    /* Reserved for future use \
						       (__ld_info64 only). */  \
	union {								       \
		int		_ldinfo_fd;	    /* fd returned by ptrace   \
						       to debugger */          \
		__I_FP(struct file,_ldinfo_fp;)     /* fp returned by          \
						       loader to ptrace */     \
		__I_INT		_core_offset;	    /* offset in core file of  \
						       object */	       \
	} _file;							       \
	__I_PTR(void)		ldinfo_textorg;	    /* start of loaded program \
						       image (includes the     \
						       XCOFF headers) */       \
	unsigned __I_INT	ldinfo_textsize;    /* length of loaded	       \
						       program image */	       \
	__I_PTR(void)		ldinfo_dataorg;	    /* start of data */        \
	unsigned __I_INT	ldinfo_datasize;    /* size of data */         \
	char			ldinfo_filename[2]; /* null-terminated path    \
						       name followed by null-  \
						       terminated member name  \
						       (if not an archive,     \
						       member name is null). */

/* Use 'struct ld_info' when calling loadquery(L_GETINFO). */
struct ld_info {
#ifndef __64BIT__
	__I_FIELDS(__I_INT32,__I_PTR32, __I_FP32, __I_EMPTY )
#else
	__I_FIELDS(__I_INT64, __I_PTR64, __I_FP64, uint ldinfo_flags;)
#endif
};

#ifdef __LDINFO_PTRACE32__
#ifdef __64BIT__

/* Use 'struct __ld_info32' when calling ptrace to debug a 32-bit process. */
struct __ld_info32 {
	__I_FIELDS(__I_INT32,__I_PTR32, __I_FP32, __I_EMPTY)
};

#else
#define __ld_info32 ld_info
#endif

#endif /* __LDINFO_PTRACE32__ */

#ifdef __LDINFO_PTRACE64__

#ifdef __64BIT__
#define __ld_info64 ld_info
#else

/* Use 'struct __ld_info64' when calling ptrace to debug a 64-bit process. */
struct __ld_info64 {
	__I_FIELDS(__I_INT64, __I_PTR64, __I_FP64, uint ldinfo_flags;)
};

#endif

#endif /* __LDINFO_PTRACE64__ */

/* Use 'struct ld_xinfo' when calling loadquery(L_GETXINFO)
 * or ptracex(PT_LDXINFO).
 */
struct ld_xinfo {
    uint	ldinfo_next;		/* offset from current entry to next
					   entry (or 0 if last entry) */
    ushort	ldinfo_flags;
    ushort	ldinfo_filename;	/* Offset from start of structure to
					   null-terminated pathname followed
					   by null-terminated member name */
    union {      
	int	_ldinfo_fd;		/* fd returned by ptrace to debugger */
	uint64_t _core_offset;		/* offset in core file of object */
#if defined(_KERNEL)
	struct file *	_ldinfo_fp;
#endif
    } _file;							      
    __ptr64	ldinfo_textorg;		/* start of loaded program image
					   (includes the XCOFF headers) */
    uint64_t	ldinfo_textsize;	/* length of loaded program image */
    __ptr64	ldinfo_dataorg;		/* start of data */       
    uint64_t	ldinfo_datasize;	/* size of data */        
    uint64_t	ldinfo_tdatasize;	/* size of tdata */
    uint64_t	ldinfo_tbsssize;	/* size of tbss */
    __ptr64	ldinfo_tdataorg;	/* start of initial tdata */
    uint64_t	ldinfo_tdataoff;	/* Offset in TLS region to tdata */
    uint	ldinfo_tls_rnum;	/* TLS region number */
};

#define	ldinfo_fd	_file._ldinfo_fd
#define	ldinfo_fp	_file._ldinfo_fp
#define ldinfo_core	_file._core_offset

#ifdef _KERNEL

/* Kernel Services */

extern int
kmod_load(caddr_t path,uint flags,caddr_t libpath,mid_t *kmid);
#define    LD_KERNELEX      0x00000001	/*flags - load as a kernel extension */
#define	   LD_USRPATH	    0x00000002  /*pathname passed is in user space  */
#define    LD_SINGLELOAD    0x00000004	/*if something is already loaded with
					 *this path name use that copy
					 *instead of a new one */
#define    LD_QUERY         0x00000008  /*just look up pathname-dont load*/
#define    LD_64BIT         0x00000010  /*mark module 64-bit aware*/
#define    LD_64L           0x00000020  /*mark module 64-L   aware*/

extern int kmod_unload(mid_t kmid,uint flags);		/* kernel unload*/

extern void (*(
kmod_entrypt(mid_t kmid,uint flags)))();	/* find the entrypoint from
						 * an mid */
/* The ld_info kernel service takes the following flags as defined for */
/* loadquery below: L_GETKERNINFO, L_GETLIB32INFO, L_GETLIB64INFO      */
extern int
ld_info(int __flags, pid_t __pid, void *__buffer, unsigned int __length);

#endif /* _KERNEL */

typedef int __LOAD_T ();		/* typedef for function with unspecified
					   arguments returning int. */
/* System calls */
extern __LOAD_T *load(char *__filenameparm, uint __flags, char *__libpathparm);

#define L_SHARED_DATA	0x00000010	/* readwrite in libarary */
					/* (not supported)*/
#define L_SHARED_ALL	0x00000020      /*      " and for libaries used */
#define	L_NOAUTODEFER	0x00000040      /* future loads don't see these */
					/* defered symbols */
#define	L_LIBPATH_EXEC	0x00000080	/* prepend libpath string used at */
					/* exec time to any libpath specified */
					/* in call to load() */
#define	L_LOADMEMBER	0x00000100	/* Load an archive member */
					/* /path/libfoo.a(member) */
#define	L_RTLD_LOCAL	0x00000200	/* runtime linker: private load */

/* loader error codes - each error string will consist of the
 * code (in characters) followed by zero or more data strings
 * seperated by blanks.  For each message, the data strings are listed.
 * (A modulename indicates a filename followed by an optional member name.) */
#define	L_ERROR_TOOMANY		1	/* too many errors, rest skipped */
					/* ARGS: none */
#define	L_ERROR_NOLIB		2	/* Can't load dependent module */
					/* ARGS: modulename */
#define	L_ERROR_UNDEF		3	/* Obsolete */
#define L_ERROR_RLDBAD		4	/* Obsolete */
#define L_ERROR_FORMAT		5	/* Module not valid, executable xcoff */
					/* ARGS: modulename */
#define L_ERROR_ERRNO		6	/* System error.  If not ENOEXEC,
					   indicates cause of error. */
					/* ARGS: error number */
#define	L_ERROR_MEMBER		7	/* Obsolete */
#define L_ERROR_TYPE		8	/* Obsolete */
#define L_ERROR_ALIGN		9	/* text alignment in file is wrong */
					/* ARGS: none */
#define L_ERROR_DOMCREAT	10	/* Insufficient permission to create
					   a loader domain */
					/* ARGS: domain name */
#define L_ERROR_DOMADD		11	/* Insufficient permission to add
					   entries to a loader domain */
					/* ARGS: domain name, modulename */
#define L_ERROR_MACHINE32	12	/* Trying to execute a 64-bit program
					   on a 32-bit machine. */
					/* ARGS: none */
#define L_ERROR_NOCONFIG64	13	/* Trying to execute a 64-bit program
					   before the 64-bit environment
					   has been configured. */
					/* ARGS: none */

#define L_ERROR_RESOLVE		30	/* Symbol resolution failed */
					/* ARGS: modulename */
#define L_ERROR_RES_L_OFFSET	31	/* symbol: bad l_offset field */
					/* ARGS: symnum */
#define L_ERROR_RES_L_SCNUM	32	/* symbol: bad l_scnum field */
					/* ARGS: symname, symnum */
#define L_ERROR_RES_L_PARM	33	/* symbol: bad l_parm field */
					/* ARGS: symname, symnum */
#define L_ERROR_RES_L_IFILE	34	/* symbol: bad l_ifile field */
					/* ARGS: symname, symnum */
#define L_ERROR_RES_XO		35	/* symbol: XO address mismatch */
					/* ARGS: symname, symnum,
						addr, modulename */
#define	L_ERROR_RES_UNDEF	36	/* undefined symbol */
					/* ARGS: symname, symnum, modulename */
#define	L_ERROR_RES_TYPE	37	/* symbol: type mismatch */
					/* ARGS: symname, symnum, modulename */
#define	L_ERROR_RES_DEFERRED	38	/* Deferred symbols not allowed */
					/* ARGS: symname, symnum */
#define L_ERROR_RES_TOOBIG	39	/* Symbol address exported from
					   64-bit kernel is too big to be
					   used by a 32-bit process.
					   ARGS: symname, symnum */
#define L_ERROR_RES_OLDSVC64	70	/* Symbol is exported from (32-bit)
					   kernel extension as SYSCALL64, but
					   the kernel extension has not been
					   updated to support the current
					   64-bit ABI.
					   ARGS: symname, symnum */

#define L_ERROR_RES_TLS_IMP	71	/* TLS ref to non-TLS symbol.
					   ARGS: symname, symnum, modulename */
#define L_ERROR_RES_TLS_EXP	72	/* Non-TLS ref to TLS symbol.
					   ARGS: symname, symnum, modulename */
#define L_ERROR_TLS_LD		73	/* LD access model, but sym is imported
					   ARGS: symname, symnum, modulename */
#define L_ERROR_TLS_IE		74	/* IE access model, but symbol is not
					   exported by exec-time module
					   ARGS: symname, symnum, modulename */
#define L_ERROR_TLS_LE		75	/* LE access model, but symbol is
					   imported or ref is not from a.out
					   ARGS: symname, symnum, modulename */

#define L_ERROR_RLD		40	/* Symbol relocation failed */
					/* ARGS: modulename */
#define L_ERROR_RLD_RSECNUM	41	/* rld: bad l_rsecnm field */
					/* ARGS: RLD number, vaddr */
#define L_ERROR_RLD_SYMNDX	42	/* rld: bad l_symndx field */
					/* ARGS: RLD number, vaddr */
#define L_ERROR_RLD_VADDR	43	/* rld: bad l_vaddr field */
					/* ARGS: RLD number, vaddr */
#define L_ERROR_RLD_RSIZE	44	/* rld: bad relocation size */
					/* ARGS: RLD number, vaddr */
#define L_ERROR_RLD_RTYPE	45	/* rld: bad l_rtype field */
					/* ARGS: RLD number, vaddr */
#define L_ERROR_RLD_TLS_RTYPE	46	/* TLS RLD not used with thread-local
					   variable or vice versa.*/
					/* ARGS: RLD number, vaddr */

#define L_ERROR_DEPENDENT	50	/* Load of dependent module failed. */
					/* ARGS: modulename */
#define L_ERROR_NOENTRY		51	/* No entry point */
					/* ARGS: None */
#define	L_ERROR_MEMBER2		52	/* Member not found in archive */
					/* ARGS: member name, archive name */
#define	L_ERROR_ARCHIVE		53	/* File not archive or Bad archive */
					/* ARGS: File name */

#define L_ERROR_NOKMEM		60	/* No kernel memory */
					/* ARGS: none */
#define L_ERROR_NOMEM		61	/* No memory available to process */
					/* ARGS: none */
#define L_ERROR_NOLPPERM	62	/* process does not have enough per-  */
					/* mission to use large pages for data*/
					/* ARGS: none */
#define	L_ERROR_RTL_UNDEF	63	/* runtime link undefined symbol */
					/* ARGS: symname, symnum */
#define L_ERROR_NSHLIB		80	/* Named shared library area */
					/* creation failed. */
					/* ARGS: area name */
#define L_ERROR_NSHLIB_SHLAP	81	/* Child SHLAP configuration failed */
					/* ARGS: None */


/* The following errors indicate problems with a module.  None of these
   messages have arguments. */
#define L_ERROR_CHECK_TRUNCATED	101	/* File is truncated or corrupted. */
#define L_ERROR_CHECK_OPTHDR	102	/* Bad auxiliary header size */
#define L_ERROR_CHECK_MAGIC	103	/* Bad magic number */
#define L_ERROR_CHECK_NSCNS	104	/* Bad number of sections */
#define L_ERROR_CHECK_SNTEXT	105	/* aux hdr: bad o_sntext field */
#define L_ERROR_CHECK_SNDATA	106	/* aux hdr: bad o_sndata field */
#define L_ERROR_CHECK_SNBSS	107	/* aux hdr: bad o_snbss field */
#define L_ERROR_CHECK_NOLOADER	108	/* No loader section */
#define L_ERROR_CHECK_SNLOADER	109	/* aux hdr: bad o_snloader field */
#define L_ERROR_CHECK_SNENTRY	110	/* aux hdr: bad o_snentry field */
#define L_ERROR_CHECK_SCNTEXT	111	/* Bad s_scnptr or s_size in
					   .text section header */
#define L_ERROR_CHECK_SCNDATA	112	/* Bad s_scnptr or s_size in
					   .data section header */
#define L_ERROR_CHECK_SCNLOADER	113	/* Bad s_scnptr or s_size in
					   .loader section header */
#define L_ERROR_CHECK_SIZES	114	/* Mismatch between section sizes in
					   auxiliary hdr and section headers. */
#define L_ERROR_CHECK_VADDRS	115	/* Mismatch between virtual addresses in
					   auxiliary hdr and section headers. */
#define L_ERROR_CHK_LDR_SN	116	/* .loader section of kernel extension
					   is not after .text and .data sects */
#define L_ERROR_CHK_DATA_ALIGN	118	/* .data sect is not properly aligned */
#define L_ERROR_CHK_NIMPID	119	/* l_nimpid in .loader header is bad */
#define L_ERROR_CHK_LDR_OFF	120	/* An offset in .loader header is bad */
#define L_ERROR_CHK_LDR_COUNT	121	/* A count in .loader header is bad */
#define L_ERROR_CHK_LDR_LENGTH	122	/* A length in .loader header is bad */

#define L_ERROR_IMPID_TRUNCATE	123	/* Import ID strings are bad */

#define L_ERROR_MAGIC_D64	124	/* Trying to load 64-bit object with
					   old magic number. */

#define L_ERROR_CHECK_SNTDATA	125	/* aux hdr: bad o_sntdata field */
#define L_ERROR_CHECK_SNTBSS	126	/* aux hdr: bad o_sntbss field */
#define L_ERROR_CHECK_SCNTDATA	127	/* Bad s_scnptr or s_size in
					   .tdata section header */
#define L_ERROR_CHECK_DYN_TLS	130	/* TLS defined by dynamically-loaded
					   module.
					*/
#define L_ERROR_CHECK_TLS_LE	131	/* TLS local-exec code not in
					   main program. */


#define	L_ERROR_SYSTEM		-1	/* system error */
					/* ARGS: any number:  provide
					   additional information. */

extern int
loadbind(int __lflags, void *__exporter, void *__importer);

extern int
unload(void *__function);
#define	L_PURGE		(void*)1	/* special parameter to unload to remove
					 * any currently unused modules in
					 * kernel or library - sysconfig	
					 * authority required*/
extern int
loadquery(int __lflags, void *__buffer, unsigned int __length, ...);
#define L_GETMESSAGES	0x00000001		/* retrieve error messages
						 */
#define L_GETINFO	0x00000002    		/* return same information
						 * ptrace gets for the current
						 * process*/
#define	L_IGNOREUNLOAD	0x10000000		/* Also get any per-process
						 * modules marked as unloaded
						 * but are still in use
						 */
#define	L_GETLIBPATH	0x00000003		/* retrieve libpath string that
						 * was used at exec() time */

/* The following 3 requests use __ld_xinfo64 structures. */
#define L_GETKERNINFO   0x00000004              /* return information about
                                                 * kernel extensions currently
                                                 * loaded. */
#define L_GETLIB32INFO  0x00000005              /* return information about
                                                 * all 32-bit shared objects
                                                 * currently loaded. */
#define L_GETLIB64INFO  0x00000006              /* return information about
                                                 * all 64-bit shared objects
                                                 * currently loaded. */

/* The following 2 requests use ld_xinfo structures. */
#define L_GETPROCINFO   0x00000007		/* Return information about
						   a specified process. */
#define L_GETXINFO	0x00000008		/* Same as L_GETINFO, except
						   struct ld_xinfo is used. */

/* The following flags are set by the loadquery function when called 
 * with L_GETKERNINFO, L_GETLIB32INFO, L_GETLIB64INFO, L_GETPROCINFO,
 * or L_GETXINFO.
 */
#define	LDINFO_DATA	0x0001		/* Entry describes data instance */
#define	LDINFO_TEXT	0x0010		/* Entry describes text instance */
#define	LDINFO_64BIT	0x0002		/* Entry describes 64-bit module */

#define LDXINFO_TDATA	0x8000	    /* In a core file, .tdata is found
				     * in core file after .data.
				     */

/* Prototype for lazy-loading error handler */
typedef void (*__handler_t( char *__module,
			   char *__symbol,
			   unsigned int __errVal ))();
extern __handler_t * __lazySetErrorHandler( __handler_t *fp );

#ifdef __cplusplus
}
#endif

#endif	/* _H_LDR */

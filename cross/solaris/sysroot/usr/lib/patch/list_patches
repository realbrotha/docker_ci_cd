#!/bin/ksh
#
# ident	"@(#)list_patches.sh	1.8	05/04/29 SMI"
#
# Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#

PATH=/usr/bin
export PATH

PATCH_HISTORY_DIR=/var/sadm/patch
PACKAGE_HISTORY_DIR=/var/sadm/pkg
PKGINFO_PATCH_FILE=/tmp/pkginfo_patch.$$

rm -f $PKGINFO_PATCH_FILE

# set up for a premature exit
trap 'rm -f $PKGINFO_PATCH_FILE; exit 0' 1 2 3 15

if [[ $1 = "-p" ]]; then

    shift

    (
	cd $PACKAGE_HISTORY_DIR
	grep "^PATCH_INFO" */pkginfo > $PKGINFO_PATCH_FILE 2> /dev/null
    )

    case $# in
    0)
	showrev -p |
	    sed -n		\
		-e 's/,//g'	\
		-e 's/^Patch: *\([^ ]*\).*Packages: *\(.*\)/\1 \2/p'
	;;
    *)
	for i
	do
	    echo "$i"
	done
	;;
    esac |
    while read PATCHID PKGS
    do
	echo $PATCHID.id=$PATCHID

	# Get synopsis and release date from README

	if [ -f $PATCH_HISTORY_DIR/$PATCHID/README.$PATCHID ]
	then
	    nawk -v PATCHID=$PATCHID '
		$0 ~ "^Synopsis:" {
		    sub("^Synopsis: *","");
		    printf "%s.syn=%s\n", PATCHID, $0;
		}
		$0 ~ "^Date:" {
		    mon = substr($2, 1, 3);
		    day = substr($2, 5, 2);
		    year = substr($2, 8, 4);
		    if (mon == "Jan") mon="01";
		    else if (mon == "Feb") mon="02";
		    else if (mon == "Mar") mon="03";
		    else if (mon == "Apr") mon="04";
		    else if (mon == "May") mon="05";
		    else if (mon == "Jun") mon="06";
		    else if (mon == "Jul") mon="07";
		    else if (mon == "Aug") mon="08";
		    else if (mon == "Sep") mon="09";
		    else if (mon == "Oct") mon="10";
		    else if (mon == "Nov") mon="11";
		    else if (mon == "Dec") mon="12";
		    else mon = "00";
		    printf "%s.rel=%4.4d%2.2d%2.2d\n", PATCHID,
			year, mon, day;
		}' $PATCH_HISTORY_DIR/$PATCHID/README.$PATCHID
	else
	    echo $PATCHID.syn=
	    echo $PATCHID.rel=
	fi

	# Get backout info

	# If we're invoked with patch ID arguments, we have to grovel
	# out the package lists ourselves.  Without arguments, we get
	# them from showrev.  Not that this sed is all that expensive,
	# but it's 1/3 of the process executions in the loop.
	if [ -z "$PKGS" ]
	then
	    PKGS=`sed -n "/:PATCH_INFO_$PATCHID/s@\([^/]*\)/pkginfo.*@\1@p" $PKGINFO_PATCH_FILE`
	fi

	BKO=false
	for PKG in $PKGS
	do
		if [ -f	$PACKAGE_HISTORY_DIR/$PKG/save/$PATCHID/undo.Z ]
		then
			BKO=true
			break
		fi
	done
	echo $PATCHID.pkg=$PKGS
	echo $PATCHID.bko=$BKO

	# Now get the required, obsoletes and incompats info
	if [ -n "$PKG" ]
	then
	    nawk -v PKG=$PKG -v PATCHID=$PATCHID '
		$0 ~ ("^" PKG "/pkginfo:PATCH_INFO_" PATCHID "=") {
		    sub("[^=]*=","");
		    m = "";
		    O[""] = 0;
		    R[""] = 0;
		    I[""] = 0;
		    for (i = 1; i <= NF; i++) {
			if ($i == "Installed:") {
			    m = "Ins";
			    n = 0;
			} else if ($i == "From:")
			    m = "Fro";
			else if ($i == "Obsoletes:")
			    m = "Obs";
			else if ($i == "Requires:")
			    m = "Req";
			else if ($i == "Incompatibles:")
			    m = "Inc";
			else if (m == "Ins") {
			    n++;
			    if (n == 1) {}
			    else if (n == 2) {
				if ($i == "Jan") mon="01";
				else if ($i == "Feb") mon="02";
				else if ($i == "Mar") mon="03";
				else if ($i == "Apr") mon="04";
				else if ($i == "May") mon="05";
				else if ($i == "Jun") mon="06";
				else if ($i == "Jul") mon="07";
				else if ($i == "Aug") mon="08";
				else if ($i == "Sep") mon="09";
				else if ($i == "Oct") mon="10";
				else if ($i == "Nov") mon="11";
				else if ($i == "Dec") mon="12";
				else mon = "00";
			    } else if (n == 3) day = $i;
			    else if (n == 4) {
				time = $i;
				gsub(":", "", time);
			    } else if (n == 5) zone = $i;
			    else if (n == 6) year = $i;
			} else if (m == "Obs")
			    O[$i] = 1;
			else if (m == "Req")
			    R[$i] = 1;
			else if (m == "Inc")
			    I[$i] = 1;
		    }
		    printf "%s.ins=%4.4d%2.2d%2.2d %s %s\n", PATCHID,
			year, mon, day, time, zone;
		    printf "%s.obs=", PATCHID;
		    sep = "";
		    for (p in O) {
			if (p != "") {
			    printf "%s%s", sep, p;
			    sep = " ";
			}
		    }
		    printf "\n";
		    printf "%s.req=", PATCHID;
		    sep = "";
		    for (p in R) {
			if (p != "") {
			    printf "%s%s", sep, p;
			    sep = " ";
			}
		    }
		    printf "\n";
		    printf "%s.inc=", PATCHID;
		    sep = "";
		    for (p in I) {
			if (p != "") {
			    printf "%s%s", sep, p;
			    sep = " ";
			}
		    }
		    printf "\n";
		}
		' $PKGINFO_PATCH_FILE
	fi
    done

    rm -f $PKGINFO_PATCH_FILE

else 
    if [ "$1" = "-z" ] 
    then
	if [ -f /usr/sbin/zoneadm ]
	then
	    EXITNUM=`/usr/sbin/zoneadm list -c | wc -l`
	else
	    EXITNUM=1
	fi
        exit $EXITNUM
    fi

    if [ "$1" = "-w" ]
	then

	/usr/sbin/smpatch getdocument withdrawn/withdrawn.zip

	if [ $? -ne 0 ]
	then
	    echo "Unable to refresh withdrawn patch list"
	    exit 2
	fi

	DOWNLOAD_CACHE_DIR=`/usr/sbin/smpatch get patchpro.cache.directory`
	if [ ! -d "$DOWNLOAD_CACHE_DIR" ]
	then
	    DOWNLOAD_CACHE_DIR_DIR=patchpro.cache.directory
	fi

	WITHDRAWN_PATHLIST_DIR="$DOWNLOAD_CACHE_DIR/withdrawn"

	SHOWREV_RESULT_FILE="$WITHDRAWN_PATHLIST_DIR/showrev.results.$$"
	WITHDRAWN_PATHLIST_FILE="$WITHDRAWN_PATHLIST_DIR/withdrawn.delimited"

	if [ -f $WITHDRAWN_PATHLIST_FILE ]
	then

	    for PATCHID in `showrev -p | grep '^Patch:' | cut -f2 -d' '`
		do
		    echo $PATCHID >> $SHOWREV_RESULT_FILE
		done

	    cat $WITHDRAWN_PATHLIST_FILE | while read line; do
		WITHDRAWN_PATCH=`echo $line | nawk -F'<!>' '{printf "%s-%s", $1, $2}'`
		grep "$WITHDRAWN_PATCH" $SHOWREV_RESULT_FILE > /dev/null

		if [ $? -eq 0 ]; then

		    echo $WITHDRAWN_PATCH.id=$WITHDRAWN_PATCH

		    if [ -f $PATCH_HISTORY_DIR/$WITHDRAWN_PATCH/README.$WITHDRAWN_PATCH ]
		    then
			nawk -v WPATCHID=$WITHDRAWN_PATCH '
			    $0 ~ "^Synopsis:" {
				sub("^Synopsis: *","");
				printf "%s.syn=%s\n", WPATCHID, $0;
			} ' $PATCH_HISTORY_DIR/$WITHDRAWN_PATCH/README.$WITHDRAWN_PATCH
		    else
			echo $WITHDRAWN_PATCH.syn=
		    fi

		fi
	    done

	    rm $SHOWREV_RESULT_FILE

	    exit 0

	else
	    echo "Withdrawn patch list is not accessible at this time. Please try again later."

	    exit 1
	fi

    else 
        showrev -p | grep '^Patch:'
    fi
fi
